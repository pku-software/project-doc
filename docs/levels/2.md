# Lv.2 语法分析器

准备妥当，可以开始编写语法分析器了。在 Lisp 中，语法分析器也可以称作“读取器”，即读取一串词法标记，得到一个值的这么个东西。OK，回顾之前提到的要实现的接口，它长这样：

```cpp
// 现在我们就认为 ValuePtr = std::share_ptr<Value> 了
ValuePtr parse(std::deque<TokenPtr> tokens);
```

不过这个接口可以写得面向对象一些，比如：

```cpp
class Parser {
public:
    Parser(std::deque<TokenPtr> tokens);
    ValuePtr parse();
}
```

至于为什么写成这样而不是过程式的接口，自有它的好处。比如，程序在进行语法分析时需要保存一些状态（当前是否位于括号内、正在分析的词法标记等等），那么这些状态信息作为私有数据成员来保存是再好不过的了。

::: warning

这里不用 `const std::deque<TokenPtr>&` 的原因是，词法标记序列需要移动到 `Parser` 内部而不是复制。注意，`TokenPtr` 是 `std::unique_ptr`，它不支持复制。

:::

## 任务 2.1 编写大体框架

新建 `parser.h` 与 `parser.cpp`，将刚刚描述的 `Parser` 类定义于其中。不要忘记包含保护。

构造函数 `Parser::Parser` 以 `std::deque` 的形式接受一系列词法标记。你可以将它保存到私有数据成员，供后续读取。接下来就开始考虑 `Parser::parse` 这个核心函数该如何编写了。

首先考虑最简单的情形，如果词法标记序列的首个词法标记是字面量的话，那就直接返回对应的值就可以。

```cpp
ValuePtr Parser::parse() {
    // 这里缺少边界检查
    auto token = this->tokens.top();
    if (token->getType() == TokenType::NUMERIC_LITERAL) {
        auto value = static_cast<NumericLiteralToken&>(*token).getValue();
        return std::make_shared<NumericValue>(value);
    }
    // [...]
}
```

这个代码展示了处理数型字面量的分支。剩下的布尔字面量、字符串字面量和符号字面量都是完完全全类似的，抄就是了。

对于其它的词法标记类别，比如引号、括号等等，就比较麻烦了。不过我们先暂时不管，直接抛出一个异常。

```cpp
#include "./error.h"

ValuePtr Parser::parse() {
    // [...]
    throw SyntaxError("Unimplemented");
}
```

最后，修改 `main.cpp`，把语法分析器接在词法分析器后面：

```cpp
auto tokens = Tokenizer::tokenize(line);
Parser parser(std::move(tokens)); // TokenPtr 不支持复制
auto value = parser.parse();
std::cout << value->toString() << std::endl; // 输出外部表示
```

效果就是一个愚蠢的复读机，但是这个复读机竟然实现了复杂的词法分析和语法分析。
```scheme
>>> #f
#f
>>> 42
42
>>> "abc"
"abc"
>>> eq?
eq?
>>>
```

## 任务 2.2 处理 S-表达式

接下来就是处理复杂一点的输入——小括号括起的前缀表达式。这种表达式有一个名字叫 **S-表达式**，在很多非 Lisp 系的语言中也有所运用。跑题了，总之我们需要将一个 S-表达式解析为列表或者对子类型的数据。

::: tip

其实词法分析+语法分析就是 `Value::toString` 的逆过程。

:::

